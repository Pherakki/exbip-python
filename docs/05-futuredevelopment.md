# Future Development
Given below is a list of potential features that should be considered (not necessarily accepted for implementation) before a v1.0 release.

- A way to extend arrays, and not just wipe them, when performing a deserialization.
- It may be necessary to conditionally erase `OffsetMarker` subscriptions if there are dynamic subscriptions during a parse operation and the binary object is parsed more than once.
- Create a 'terse-mode' struct declaration that generates a struct based on `ctypes` just by using class-level type annotations. This should automatically create `exbip_rw` and fully support mixed endianness. An incomplete test implementation is in the `dev` directory. This will likely require a parallel system of annotation types to the descriptor system.
- Expand the concept of 'contexts' beyond just endianness switching to create arbitrary contexts as mix-in classes.
    - Array reads would be significantly faster if `numpy` were used as a backend. Configuring whether primitive array descriptors use `struct` or `numpy` as a backend could be handled with a monkey-patched context, like endianness currently is.
    - Switching between contiguous and non-contiguous reads could be a context option rather than requiring extra classes.
    - This will eliminate the need for _e.g._ a distinction between `Reader` and `NonContiguousReader` and generalise these concepts without the need for explicit hardcoding.
- Separate the concept of stream-handing from the parser classes themselves. A parser should interact with an `exbip` stream API that a stream-wrapper object must provide in order to wrap a stream. To prevent function call and attribute access overhead, this API should return member functions of the wrapped stream that are monkey-patched onto the parser within the confines of a context manager.
- Implement parsers that can read and write tagged schemas _e.g._ `json` and `XML` files.
    - This will required implementing 'tagged' versions of the primitive descriptors that also take a name, which is the label the descriptor is exported under.
- Implement a parser that is an AST/code generator. The purpose of the parser is to create an AST that can be analysed in order to inline function calls and merge stream reads and writes into larger memory accesses, and can then be dumped to a Python file or compiled to an object as an optimised parser. This would essentially be a small optimising compiler acting on an AST generated by the parser.
